#!/usr/bin/ansible-playbook
#
# Deploy Cluster Operator to the cluster for the current users kubeconfig context.
#
# Several pieces of secret data (certs, ssh keys) are assumed to be shared amongst the team
# maintaining the deployment. As such the playbook checks if they exist, if they do not it
# attempt to generate/create them. Some of these steps may require local setup. However once
# the secrets are created initially, the deployment ansible will leave them be and other
# members of the team can update the deployment without needing to locally have the shared
# SSH key or AWS credentials.
---
- hosts: localhost
  connection: local
  gather_facts: no
  vars:
    # Namespace to deploy CO to:
    cluster_operator_namespace: "openshift-cluster-operator"
    # Force regeneration of apiserver cluster cert. Will happen regardless if one does not exist.
    # found to not exist.
    redeploy_apiserver_cert: False
    # Whether or not we should process the template with cluster roles, service accounts, etc.
    # These are separated for deployments where a cluster admin may need to set these up one time,
    # but users with lesser permissions can maintain the actual deployment itself.
    deploy_roles: True
  tasks:
  - set_fact:
      cluster_operator_namespace: "{{ cli_cluster_operator_namespace }}"
    when: cli_cluster_operator_namespace is defined

  - name: create cluster-operator namespace
    k8s_raw:
      name: "{{ cluster_operator_namespace }}"
      api_version: v1
      kind: Namespace
      state: present

  - name: check if apiserver cert secret exists
    command: "oc get secret cluster-operator-apiserver-cert -n {{ cluster_operator_namespace }}"
    failed_when: false
    changed_when: false
    register: apiserver_cert_exists_reg

  - set_fact:
      redeploy_apiserver_cert: True
    when: apiserver_cert_exists_reg.rc > 0 and "NotFound" in apiserver_cert_exists_reg.stderr

  # TODO: replace with openssl_certificate but watch out for need for a CA
  - name: generate apiserver certs
    command: "{{ playbook_dir }}/../apiserver-aggregation-tls-setup.sh"
    args:
      # ensure these land in the top level of the project where expected
      chdir: "{{ playbook_dir }}/../../"
      # only runs if this file does not exist in top level of the git repo.
      creates: "{{ playbook_dir }}/../../apiserver.pem"
    when: redeploy_apiserver_cert | bool

  - set_fact:
      # base-64-encoded, pem CA cert for the ssl certs
      l_serving_ca: "{{ lookup('file', playbook_dir + '/../../ca.pem') | b64encode }}"
      # base-64-encoded, pem cert to use for ssl communication with the Cluster Operator API Server
      l_serving_cert: "{{ lookup('file', playbook_dir + '/../../apiserver.pem') | b64encode }}"
      # base-64-encoded, pem private key for the cert to use for ssl communication with the Cluster Operator API Server.
      l_serving_key: "{{ lookup('file', playbook_dir + '/../../apiserver-key.pem') | b64encode }}"
    when: redeploy_apiserver_cert | bool

  - name: create apiserver cert secret
    k8s_raw:
      state: present
      definition:
        # Secret to pass the SSL certs to the API Server
        apiVersion: v1
        kind: Secret
        metadata:
          name: cluster-operator-apiserver-cert
          namespace: "{{ cluster_operator_namespace }}"
          labels:
            app: cluster-operator-apiserver
        type: Opaque
        data:
          tls.crt: "{{ l_serving_cert }}"
          tls.key: "{{ l_serving_key }}"
          ca.crt: "{{ l_serving_ca }}"
    when: redeploy_apiserver_cert | bool

  - name: load serving CA from secret
    command: "oc get secret -n {{ cluster_operator_namespace }} cluster-operator-apiserver-cert -o json"
    register: cluster_cert_secret_reg
    changed_when: false

  # Ensure l_serving_ca is set even if we did not regen certs, as it's needed for the apiserver aggregation:
  - set_fact:
      l_serving_ca: "{{ (cluster_cert_secret_reg.stdout | from_json)['data']['ca.crt'] }}"

  - name: deploy cluster operator service accounts, roles and bindings
    shell: "oc process -f {{ playbook_dir }}/../examples/cluster-operator-roles-template.yaml -o yaml -p CLUSTER_OPERATOR_NAMESPACE={{ cluster_operator_namespace }} | oc apply -f -"
    when: deploy_roles | bool

  - name: deploy application template
    shell: "oc process -f {{ playbook_dir }}/../examples/cluster-operator-template.yaml -o yaml -p CLUSTER_OPERATOR_NAMESPACE={{ cluster_operator_namespace }} -p SERVING_CA={{ l_serving_ca }} | oc apply -f -"

